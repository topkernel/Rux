//! 8x8 位图字体渲染
//!
//! 提供基础的 ASCII 字符渲染功能 (0x20-0x7F)

/// 颜色常量 (xRGB 格式)
pub mod color {
    pub const BLACK: u32 = 0xFF000000;
    pub const WHITE: u32 = 0xFFFFFFFF;
    pub const RED: u32 = 0xFFFF0000;
    pub const GREEN: u32 = 0xFF00FF00;
    pub const BLUE: u32 = 0xFF0000FF;
    pub const YELLOW: u32 = 0xFFFFFF00;
    pub const CYAN: u32 = 0xFF00FFFF;
    pub const MAGENTA: u32 = 0xFFFF00FF;
    pub const GRAY: u32 = 0xFF808080;
    pub const DARK_GRAY: u32 = 0xFF404040;
    pub const LIGHT_BLUE: u32 = 0xFF0000FF;
}

/// 8x8 位图字体数据
///
/// 每个字符用 8 个字节表示，每个字节的 8 位对应一行
/// 示例：字符 'A' = 0x3C6660666E66663C
pub const FONT_8x8: &[u8; 1024] = &[
    // 0x20 (Space) - 0x2F (/)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ' '
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, // '!'
    0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // '"'
    0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00, // '#'
    0x0C, 0x3E, 0x03, 0x0E, 0x30, 0x3F, 0x0C, 0x00, // '$'
    0x00, 0x63, 0x33, 0x1E, 0x7C, 0x38, 0x00, 0x00, // '%'
    0x0C, 0x18, 0x30, 0x18, 0x0C, 0x18, 0x00, 0x00, // '&'
    0x03, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, // '''
    0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00, // '('
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00, // ')'
    0x00, 0x36, 0x1C, 0x7F, 0x1C, 0x36, 0x00, 0x00, // '*'
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, // '+'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, // ','
    0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, // '-'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, // '.'
    0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, // '/'

    // 0x30-0x3F (0-9 :)
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00, // '0'
    0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, // '1'
    0x1E, 0x33, 0x03, 0x1E, 0x30, 0x3F, 0x3F, 0x00, // '2'
    0x1E, 0x33, 0x03, 0x1E, 0x03, 0x33, 0x1E, 0x00, // '3'
    0x38, 0x3C, 0x36, 0x1E, 0x03, 0x03, 0x03, 0x00, // '4'
    0x3F, 0x30, 0x1E, 0x03, 0x33, 0x33, 0x1E, 0x00, // '5'
    0x1E, 0x30, 0x3E, 0x33, 0x33, 0x33, 0x1E, 0x00, // '6'
    0x3F, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x00, // '7'
    0x3E, 0x33, 0x3E, 0x33, 0x33, 0x33, 0x3E, 0x00, // '8'
    0x3E, 0x33, 0x33, 0x3E, 0x03, 0x33, 0x1E, 0x00, // '9'
    0x00, 0x00, 0x1E, 0x00, 0x00, 0x1E, 0x00, 0x00, // ':'
    0x00, 0x00, 0x1E, 0x00, 0x00, 0x1E, 0x18, 0x00, // ';'
    0x00, 0x18, 0x0C, 0x30, 0x60, 0x30, 0x0C, 0x18, // '<'
    0x00, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x00, 0x00, // '='
    0x00, 0x30, 0x18, 0x0C, 0x06, 0x18, 0x30, 0x00, // '>'
    0x1E, 0x33, 0x03, 0x0E, 0x00, 0x00, 0x00, 0x00, // '?'

    // 0x40-0x4F (@A-O)
    0x3E, 0x63, 0x7B, 0x7B, 0x63, 0x3E, 0x00, 0x00, // '@'
    0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, // 'A'
    0x3F, 0x33, 0x3F, 0x33, 0x3F, 0x33, 0x3E, 0x00, // 'B'
    0x1E, 0x33, 0x30, 0x30, 0x30, 0x33, 0x1E, 0x00, // 'C'
    0x3B, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3B, 0x00, // 'D'
    0x3F, 0x30, 0x3C, 0x30, 0x30, 0x30, 0x3F, 0x00, // 'E'
    0x3F, 0x30, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x00, // 'F'
    0x1E, 0x33, 0x30, 0x3E, 0x33, 0x33, 0x1E, 0x00, // 'G'
    0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x33, 0x00, // 'H'
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x1E, 0x00, // 'I'
    0x03, 0x03, 0x03, 0x03, 0x33, 0x33, 0x1E, 0x00, // 'J'
    0x33, 0x33, 0x36, 0x1C, 0x36, 0x33, 0x33, 0x00, // 'K'
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1E, 0x00, // 'L'
    0x63, 0x77, 0x7B, 0x7B, 0x63, 0x63, 0x63, 0x00, // 'M'
    0x3F, 0x33, 0x33, 0x3B, 0x33, 0x33, 0x33, 0x00, // 'N'
    0x1E, 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00, // 'O'

    // 0x50-0x5F (P-Z)
    0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x00, // 'P'
    0x1E, 0x33, 0x33, 0x3B, 0x33, 0x33, 0x1E, 0x00, // 'Q'
    0x3F, 0x33, 0x3F, 0x36, 0x33, 0x33, 0x33, 0x00, // 'R'
    0x1E, 0x30, 0x30, 0x1E, 0x03, 0x33, 0x1E, 0x00, // 'S'
    0x3F, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, // 'T'
    0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00, // 'U'
    0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00, // 'V'
    0x33, 0x33, 0x33, 0x3B, 0x33, 0x33, 0x33, 0x00, // 'W'
    0x63, 0x33, 0x36, 0x1C, 0x36, 0x33, 0x63, 0x00, // 'X'
    0x33, 0x33, 0x33, 0x1E, 0x03, 0x33, 0x33, 0x00, // 'Y'
    0x3F, 0x33, 0x03, 0x0E, 0x30, 0x33, 0x3F, 0x00, // 'Z'

    // 0x60-0x6F (`a-o)
    0x00, 0x00, 0x00, 0x3F, 0x30, 0x33, 0x3E, 0x00, // '`'
    0x00, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x00, 0x00, // 'a'
    0x30, 0x00, 0x3E, 0x33, 0x33, 0x33, 0x3E, 0x00, // 'b'
    0x00, 0x00, 0x3E, 0x30, 0x30, 0x30, 0x1E, 0x00, // 'c'
    0x30, 0x00, 0x3E, 0x33, 0x33, 0x33, 0x3E, 0x00, // 'd'
    0x00, 0x00, 0x1E, 0x33, 0x3F, 0x30, 0x1E, 0x00, // 'e'
    0x00, 0x00, 0x3C, 0x3F, 0x3C, 0x30, 0x30, 0x00, // 'f'
    0x00, 0x00, 0x3E, 0x33, 0x33, 0x33, 0x3E, 0x33, // 'g'
    0x33, 0x00, 0x3F, 0x33, 0x33, 0x33, 0x33, 0x00, // 'h'
    0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x00, // 'i'
    0x03, 0x00, 0x03, 0x03, 0x33, 0x33, 0x1E, 0x00, // 'j'
    0x33, 0x00, 0x33, 0x36, 0x1C, 0x36, 0x33, 0x00, // 'k'
    0x30, 0x00, 0x30, 0x30, 0x30, 0x30, 0x1E, 0x00, // 'l'
    0x00, 0x00, 0x33, 0x7B, 0x7B, 0x33, 0x33, 0x00, // 'm'
    0x00, 0x00, 0x3B, 0x33, 0x33, 0x33, 0x33, 0x00, // 'n'
    0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00, // 'o'

    // 0x70-0x7F (p-z)
    0x00, 0x00, 0x3E, 0x33, 0x3E, 0x30, 0x30, 0x00, // 'p'
    0x00, 0x00, 0x3B, 0x33, 0x33, 0x3B, 0x03, 0x00, // 'q'
    0x00, 0x00, 0x3E, 0x30, 0x1E, 0x03, 0x33, 0x00, // 'r'
    0x00, 0x00, 0x1E, 0x03, 0x0E, 0x30, 0x00, 0x00, // 's'
    0x08, 0x18, 0x3E, 0x08, 0x08, 0x08, 0x00, 0x00, // 't'
    0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00, // 'u'
    0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x0E, 0x00, // 'v'
    0x00, 0x00, 0x33, 0x33, 0x33, 0x3B, 0x33, 0x00, // 'w'
    0x00, 0x00, 0x33, 0x33, 0x0E, 0x0C, 0x33, 0x00, // 'x'
    0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x03, 0x00, // 'y'
    0x00, 0x00, 0x3F, 0x03, 0x0E, 0x33, 0x3F, 0x00, // 'z'

    // 0x7F (DEL) - 0x7F
    0x00, 0x1E, 0x36, 0x63, 0x3C, 0x18, 0x00, 0x00, // '{'
    0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, // '|'
    0x00, 0x3C, 0x18, 0x63, 0x36, 0x1E, 0x00, 0x00, // '}'
    0x1E, 0x30, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, // '~'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // DEL
];

/// 字体渲染器
pub struct FontRenderer {
    /// 字体宽度
    width: u32,
    /// 字体高度
    height: u32,
}

impl FontRenderer {
    /// 创建 8x8 字体渲染器
    pub const fn new_8x8() -> Self {
        Self {
            width: 8,
            height: 8,
        }
    }

    /// 获取字体宽度
    #[inline]
    pub const fn width(&self) -> u32 {
        self.width
    }

    /// 获取字体高度
    #[inline]
    pub const fn height(&self) -> u32 {
        self.height
    }

    /// 绘制单个字符
    ///
    /// # 参数
    /// - `fb`: framebuffer
    /// - `x`: X 坐标
    /// - `y`: Y 坐标
    /// - `ch`: 字符 (ASCII)
    /// - `color`: 前景色
    pub fn draw_char<F: Framebuffer>(&self, fb: &F, x: u32, y: u32, ch: u8, color: u32)
    where
        F: Framebuffer,
    {
        if ch < 0x20 || ch > 0x7F {
            return;
        }

        let idx = (ch - 0x20) as usize;
        let base = idx * 8;

        for py in 0..8 {
            let row_data = FONT_8x8[base + py as usize];
            for px in 0..8 {
                let bit = (row_data >> (7 - px)) & 1;
                if bit != 0 {
                    fb.put_pixel(x + px, y + py, color);
                }
            }
        }
    }

    /// 绘制字符串
    ///
    /// # 参数
    /// - `fb`: framebuffer
    /// - `x`: X 坐标
    /// - `y`: Y 坐标
    /// - `text`: 字符串
    /// - `color`: 前景色
    pub fn draw_string<F: Framebuffer>(&self, fb: &F, mut x: u32, mut y: u32, text: &str, color: u32)
    where
        F: Framebuffer,
    {
        for ch in text.bytes() {
            match ch {
                b'\n' => {
                    y += self.height;
                    x = 0;
                }
                b' ' => {
                    // 普通空格
                }
                _ => {
                    self.draw_char(fb, x, y, ch, color);
                    x += self.width;
                }
            }
        }
    }

    /// 计算文本宽度
    pub fn measure_text(&self, text: &str) -> u32 {
        let mut width = 0u32;
        for ch in text.bytes() {
            match ch {
                b'\n' => break,
                b' ' => width += self.width,
                _ if ch >= 0x20 && ch <= 0x7F => width += self.width,
                _ => {}
            }
        }
        width
    }

    /// 计算文本行数
    pub fn count_lines(&self, text: &str) -> u32 {
        let mut lines = 1u32;
        for ch in text.bytes() {
            if ch == b'\n' {
                lines += 1;
            }
        }
        lines
    }
}

/// Framebuffer trait
pub trait Framebuffer {
    fn put_pixel(&self, x: u32, y: u32, color: u32);
}

// 为 FrameBuffer 实现 Framebuffer trait
use crate::drivers::gpu::framebuffer::FrameBuffer;

impl Framebuffer for FrameBuffer {
    fn put_pixel(&self, x: u32, y: u32, color: u32) {
        self.put_pixel(x, y, color);
    }
}
